// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name OSFirebaseMessagingLib
import CoreData
import Foundation
@_exported import OSFirebaseMessagingLib
import Swift
import UIKit
import UserNotifications
import _Concurrency
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(OSNotification) public class OSNotification : CoreData.NSManagedObject, Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  required convenience public init(from decoder: Swift.Decoder) throws
  @objc deinit
}
public enum FirebaseMessagingErrors : Swift.Int, Foundation.CustomNSError, Foundation.LocalizedError {
  case registrationError
  case unregistrationError
  case subscriptionError
  case unsubscriptionError
  case obtainingTokenError
  case deletingTokenError
  case settingBadgeNumberError
  case gettingBadgeNumberError
  case requestPermissionsError
  case permissionsDeniedByUser
  case invalidConfigurations
  case errorSendingNotification
  case errorDeletingNotifications
  case errorInsertingNotifications
  case errorObtainingNotifications
  public var description: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public typealias CompletionHandler = (Swift.Result<Swift.String?, Swift.Error>) -> Swift.Void
public protocol MessagingProtocol {
  func getGeneralTopic() -> Swift.String
  func getToken(completion: @escaping OSFirebaseMessagingLib.CompletionHandler)
  func deleteToken(completion: @escaping OSFirebaseMessagingLib.CompletionHandler)
  func subscribe(toTopic topic: Swift.String, completion: @escaping OSFirebaseMessagingLib.CompletionHandler)
  func unsubscribe(fromTopic topic: Swift.String, completion: @escaping OSFirebaseMessagingLib.CompletionHandler)
}
public class FirebaseConfiguration {
  public static let googleServicesFileName: Swift.String
  public init(fileName: Swift.String = googleServicesFileName, bundle: Foundation.Bundle = Bundle.main)
  public func getGoogleServicesPath() -> Swift.String?
  @objc deinit
}
public protocol FirebaseMessagingCallbackProtocol {
  func callback(result: Swift.String?, error: OSFirebaseMessagingLib.FirebaseMessagingErrors?)
}
public protocol FirebaseMessagingEventProtocol {
  func event(data: Swift.String)
}
extension Swift.Encodable {
  public func encode() -> Swift.String
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class FirebaseMessagingApplicationDelegate : ObjectiveC.NSObject, UIKit.UIApplicationDelegate {
  @_Concurrency.MainActor(unsafe) public var coreDataManager: OSFirebaseMessagingLib.CoreDataManager {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var notificationManager: OSFirebaseMessagingLib.NotificationManager {
    get
    set
  }
  @objc @_Concurrency.MainActor(unsafe) public static let shared: OSFirebaseMessagingLib.FirebaseMessagingApplicationDelegate
  @_Concurrency.MainActor(unsafe) public var eventDelegate: OSFirebaseMessagingLib.FirebaseMessagingEventProtocol?
  @_Concurrency.MainActor(unsafe) @objc public func application(_ application: UIKit.UIApplication, didFinishLaunchingWithOptions launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]? = nil) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc public func application(_ application: UIKit.UIApplication, didReceiveRemoteNotification userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc public func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  @objc deinit
}
extension OSFirebaseMessagingLib.FirebaseMessagingApplicationDelegate : UserNotifications.UNUserNotificationCenterDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
}
public protocol UIApplicationProtocol {
  func getBadge() -> Swift.Int
  func setBadge(badge: Swift.Int)
}
extension UIKit.UIApplication : OSFirebaseMessagingLib.UIApplicationProtocol {
  @_Concurrency.MainActor(unsafe) public func getBadge() -> Swift.Int
  @_Concurrency.MainActor(unsafe) public func setBadge(badge: Swift.Int)
}
public class MessagingManager : OSFirebaseMessagingLib.MessagingProtocol {
  public init()
  public func getGeneralTopic() -> Swift.String
  public func getToken(completion: @escaping OSFirebaseMessagingLib.CompletionHandler)
  public func deleteToken(completion: @escaping OSFirebaseMessagingLib.CompletionHandler)
  public func subscribe(toTopic topic: Swift.String, completion: @escaping OSFirebaseMessagingLib.CompletionHandler)
  public func unsubscribe(fromTopic topic: Swift.String, completion: @escaping OSFirebaseMessagingLib.CompletionHandler)
  @objc deinit
}
public protocol NotificationManagerProtocol {
  func insertNotification(notificationDict: [Swift.String : Any]) -> Swift.Result<Swift.Bool, OSFirebaseMessagingLib.FirebaseMessagingErrors>
  func fetchNotifications() -> Swift.Result<[OSFirebaseMessagingLib.OSNotification], Swift.Error>
  
  #if compiler(>=5.3) && $AsyncAwait
  func sendLocalNotification(title: Swift.String, body: Swift.String, badge: Swift.Int) async -> Swift.Result<Swift.Bool, Swift.Error>
  #endif

}
@objc @_hasMissingDesignatedInitializers final public class NotificationManager : ObjectiveC.NSObject {
  convenience public init(coreDataManager: OSFirebaseMessagingLib.CoreDataManager = CoreDataManager())
  
  #if compiler(>=5.3) && $AsyncAwait
  final public func sendLocalNotification(title: Swift.String, body: Swift.String, badge: Swift.Int) async -> Swift.Result<Swift.Bool, Swift.Error>
  #endif

  @objc deinit
}
extension OSFirebaseMessagingLib.NotificationManager : OSFirebaseMessagingLib.NotificationManagerProtocol {
  final public func deletePendingNotifications(_ notifications: [OSFirebaseMessagingLib.OSNotification]) -> Swift.Result<Swift.Bool, Swift.Error>
  final public func insertNotification(notificationDict: [Swift.String : Any]) -> Swift.Result<Swift.Bool, OSFirebaseMessagingLib.FirebaseMessagingErrors>
  final public func fetchNotifications() -> Swift.Result<[OSFirebaseMessagingLib.OSNotification], Swift.Error>
}
@objc @_hasMissingDesignatedInitializers open class FirebaseMessagingController : ObjectiveC.NSObject {
  convenience public init(delegate: OSFirebaseMessagingLib.FirebaseMessagingCallbackProtocol, firebaseManager: OSFirebaseMessagingLib.MessagingManager = MessagingManager(), coreDataManager: OSFirebaseMessagingLib.CoreDataManager = CoreDataManager())
  public func getPendingNotifications(clearFromDatabase: Swift.Bool = false)
  public func getToken()
  public func deleteToken()
  public func subscribe(topic: Swift.String)
  public func unsubscribe(fromTopic topic: Swift.String)
  public func clearNotifications()
  
  #if compiler(>=5.3) && $AsyncAwait
  public func sendLocalNotification(title: Swift.String, body: Swift.String, badge: Swift.Int) async
  #endif

  public func setBadge(badge: Swift.Int)
  public func getBadge()
  public func registerDevice()
  public func unregisterDevice()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc open class CoreDataManager : ObjectiveC.NSObject {
  public static let modelName: Swift.String
  public static let model: CoreData.NSManagedObjectModel
  public var storeContainer: CoreData.NSPersistentContainer {
    get
    set
  }
  public func context() -> CoreData.NSManagedObjectContext
  public func fetch<T>(_ request: CoreData.NSFetchRequest<T>) throws -> [T] where T : CoreData.NSFetchRequestResult
  public func saveContext() throws
  @objc override dynamic public init()
  @objc deinit
}
extension OSFirebaseMessagingLib.OSNotification {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<OSFirebaseMessagingLib.OSNotification>
  @objc @NSManaged dynamic public var extraData: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var messageID: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timeStamp: Swift.Double {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timeToLive: Swift.String? {
    @objc get
    @objc set
  }
}
extension OSFirebaseMessagingLib.OSNotification : Swift.Identifiable {
  public typealias ID = Swift.ObjectIdentifier
}
extension OSFirebaseMessagingLib.FirebaseMessagingErrors : Swift.Equatable {}
extension OSFirebaseMessagingLib.FirebaseMessagingErrors : Swift.Hashable {}
extension OSFirebaseMessagingLib.FirebaseMessagingErrors : Swift.RawRepresentable {}
